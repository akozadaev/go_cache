# go_cachefifo

Сборник небольших примеров, показывающих разные подходы к организации кеша в Go: от встроенных структур до сторонних библиотек и собственной реализации политики LRU.

## 1. In-memory кеш на `sync.Map`

Каталог `1_In_memory_sync_Map_main` демонстрирует минималистичный кеш, обёрнутый над потокобезопасной структурой `sync.Map`.

- Интерфейс: методы `Set` и `Get` записывают и извлекают значения по ключу, используя встроенные `Store`/`Load`.
- Потокобезопасность: `sync.Map` берёт на себя синхронизацию, поэтому отдельные блокировки не нужны.
- Сценарий: main-функция кладёт в кеш значение `user:1 → "Алексей"` и сразу его читает.
- Ограничения: нет TTL, контроля размера и механизма сброса — кеш растёт бессистемно.

## 2. Кеш с ограничением по времени жизни

Каталог `2_with_ttl` использует библиотеку [`github.com/patrickmn/go-cache`](https://github.com/patrickmn/go-cache) для хранения данных с TTL.

- Инициализация: `cache.New(5*time.Minute, 10*time.Minute)` — элементы живут 5 минут, служебная очистка запускается каждые 10 минут.
- Уровень API: `Set` задаёт TTL для ключа (можно указывать индивидуальный или `cache.DefaultExpiration`), `Get` возвращает значение и признак валидности.
- Демонстрация: после `time.Sleep(6 * time.Minute)` ключ становится недоступен, что имитирует автоудаление протухших данных.
- Преимущества: потокобезопасность «из коробки», готовые методы сериализации и массовой загрузки; подходит для кеша конфигурации, запросов к внешним API и т.п.

## 3. LRU-кеши (ограничение по количеству элементов)

Каталог `3_lru` показывает несколько вариантов реализации стратегии «Least Recently Used».

### 3.1 Быстрый старт на готовой библиотеке

Файл `3_lru/main.go` демонстрирует использование [`github.com/hashicorp/golang-lru/v2`](https://github.com/hashicorp/golang-lru):

- `lru.New[string, int](3)` создаёт кеш, запоминая первые три обращения.
- При добавлении четвёртого ключа `Add("d", 4)` автоматически удаляется наименее недавно использованный (`"b"`).
- Метод `Get` возвращает пару `(значение, найден ли ключ)`, что удобно для паттерна «прочитал — использовал — обновил».

### 3.2 Собственная реализация LRU без потокобезопасности

Файлы `custom/lru_cache.go` и `custom/main.go` предлагают учебный пример, иллюстрирующий работу LRU с использованием стандартного пакета `container/list`.

- Структура данных: двусвязный список хранит порядок использования, а карта `map[string]*list.Element` обеспечивает O(1) доступ по ключу.
- Методы `Add`, `Get`, `Remove`, `Size` реализуют типичный контракт кеша.
- Алгоритмика: при чтении/записи элемент перемещается в начало списка, а при переполнении вызывается `removeOldest`, удаляющий хвостовой элемент.
- Цель примера — показать базовую механику и возможность расширить кеш (например, добавить TTL или сериализацию).

### 3.3 Потокобезопасный LRU с дженериками

Каталог `custom_thread_safe` переиспользует идею из предыдущего примера, но добавляет:

- Обобщение по типам ключа и значения (`Cache[K comparable, V any]`).
- Защиту от гонок: `sync.Mutex` блокирует операции `Get`, `Add`, `Remove`, `Size`.
- Отдельный пакет с модулем Go (`go.mod`) и примером использования (`cmd/main.go`), что упрощает подключение в других проектах.

### 3.4 Дополнительные эксперименты

Файл `custom.go` служит иллюстрацией для работы с фиксированным массивом структур и не реализует полноценного LRU; его можно рассматривать как шаг до перехода на двусвязный список.

## 4. LFU-кеши (ограничение по частоте использования)

Каталог `4_lfu` добавляет стратегию «Least Frequently Used», где вытесняются элементы с наименьшим числом обращений.

- **Базовый вариант** (`main.go`, `lfu_cache.go`): реализация на `container/list`, которая поддерживает карты `частота → двусвязный список` и обновляет `minFreq` при каждом обращении. Показывает, как устроена типичная LFU-структура без потокобезопасности.
- **Потокобезопасный вариант** (`custom_thread_safe/`): обобщённый по типам ключей/значений, защищён `sync.Mutex`, что позволяет использовать кеш в нескольких горутинах. В каталоге есть `cmd/main.go` с примером запуска.
- Обе реализации предоставляют одинаковый интерфейс с методами `Add`, `Get`, `Remove`, `Size`, что упрощает сравнение подходов и подключение к существующему коду.

## 5. FIFO-кеш (первым пришёл — первым ушёл)

Каталог `5_fifo` показывает самый простой сценарий вытеснения: новые элементы вытесняют самые старые независимо от частоты или давности доступа.

- `fifo_cache.go` — реализация на `container/list`, использующая очередь и карту для O(1) доступа.
- Метод `Add` при переполнении вызывает `evict`, удаляющий элемент из головы очереди.
- `Get` возвращает значение без изменения порядка, что подчёркивает «очередную» семантику FIFO.
- `main.go` демонстрирует вытеснение ключа `a` после добавления третьего элемента в кэш ёмкостью 2.

## 6. Кеширование в Redis

Каталог `6_redis` демонстрирует работу с внешним in-memory хранилищем на базе Redis с помощью клиента [`github.com/redis/go-redis/v9`](https://github.com/redis/go-redis).

- `main.go` устанавливает соединение с локальным Redis (`localhost:6379`), проверяет доступность командой `PING`, записывает значение с TTL и считывает его.
- После паузы (`time.Sleep`) ключ истекает, и повторная попытка чтения приводит к ошибке `redis.Nil`, что иллюстрирует поведение Redis как кеша с ограничением по времени жизни.
- Пример использует контекст `context.Background()` и показывает типичный код инициализации клиента, что можно адаптировать для использования в веб-сервисах.

---

### Как запускать примеры

Перейдите в корень нужного каталога и выполните:

```bash
go run .
```

Каждый пример — самостоятельный модуль/пакет, поэтому зависимости подтягиваются автоматически (см. соответствующие `go.mod`).